指针：
1、绝不要对未初始化的指针解除引用。
2、在多数情况下，数组名为第一个元素的地址，一种例外：将sizeof用于数组名时，将返回整个数组的长度。
3、可以将指针与整数相加，加1的结果等于原来的地址加上指向对象占用的总字节数。还可以减1。
4、可以将一个指针减去另一个指针，获取两个指针的差，要求两个指针指向同一个数组。
5、采用静态联编，数组的长度在编译时设置；采用动态数组，用new运算符，数组的长度将在运行时设置，即分配空间，使用完这个数组后应使用delete [] 指针名 释放其占用的内存。

6、使用方括号数组表示法等同于对指针解除引用

7、数组名一般表示第一个元素的地址，例外情况：使用sizeof+数组名，表示整个数组的字符长度.

8、cout<<数组名 表示提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。


句柄（windows应用程序下的句柄）：
1、句柄变量是个几字节大小的存储空间，windows不允许在程序里直接访问这些内核对象的内存，而是通过调用windows提供给我们的函数来返回一个句柄，我们再用这个句柄作为执行特定行为的函数的参数去完成对内核对象的操作

2、内核对象可以在进程间共享，但是同一个内核对象的句柄值在不同进程中不一定相同

3、句柄值是进程相关的，不同进程能使用相同的句柄值，但是不要指望它们能绝对指向同一个内核对象

4、句柄地址（稳定）->记载着对象在内存中的地址->对象在内存中的地址（不稳定）->实际对象

5、程序每次重新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄

6、句柄是WINDOWS用来标识被应用程序所建立或使用的对象的唯一整数，WINDOWS使用各种各样的句柄标识诸如应用程序实例，窗口，控制，位图，GDI对象等等


句柄是用来标识项目的，项目包括：
　　*.模块(module)
　　*.任务(task)
　　*.实例(instance)
　　*.文件(file)
　　*.内存块(block of memory)
　　*.菜单(menu)
　　*.控件(control)
　　*.字体(font)
　　*.资源(resource),包括图标(icon)，光标(cursor)，字符串(string)等
　　*.GDI对象(GDI object),包括位图(bitmap)，画刷(brush)，元文件（metafile),调色板(palette)，画笔(pen)，区域(region)，以及设备描述表(device context)。



LPSTR是指向以NULL(‘\0’)结尾的32位ANSI字符串的长指针字符串数据类型


LPSTR = char*
LPCSTR = const char*
LPWSTR = wchar_t*
LPCWSTR = const wchar_t*
LPTSTR = char* or wchar_t* depending on _UNICODE
LPCTSTR = const char* or const wchar_t* depending on _UNICODE

头文件(.h)：
写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。

在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：

#ifndef CIRCLE_H
#define CIRCLE_H

//你的代码写在这里

#endif


这样做是为了防止重复编译，避免同一个文件被include多次.


#pragma once 与 #ifndef 解析:

#pragma once方式不受一些较老版本的编译器支持



typedef typeName 别名  //此方式可以用别名声明一系列变量，不会创建新的类型，只是建立新名称
#define 别名 typeName

函数的重载：允许对多个相关的函数使用相同的名称，这些函数以不同的方式或正对不同的类型执行相同的基本任务。

不接受任何参数的cin.get()返回输入中的下一个字符。

cctype头文件中定义的函数：

isalnum()	如果参数是字母数字，即字母或数字，该函数返回true
isalpha()	如果参数是字母，该函数返回真
isblank()	如果参数是空格或水平制表符，该函数返回true
iscntrl()	如果参数是控制字符，该函数返回true
isdigit()	如果参数是数字（0～9），该函数返回true
isgraph()	如果参数是除空格之外的打印字符，该函数返回true
islower()	如果参数是小写字母，该函数返回true
isprint()	如果参数是打印字符（包括空格），该函数返回true
ispunct()	如果参数是标点符号，该函数返回true
isspace()	如果参数是标准空白字符，如空格、进纸、换行符、回车
、水平制表符或者垂直制表符，该函数返回true

isupper()	如果参数是大写字母，该函数返回true
isxdigit()	如果参数是十六进制的数字，即0～9、a~f、A~F，该函数返回true
tolower()	如果参数是大写字符，则返回其小写，否则返回该参数
toupper()	如果参数是小写字母，则返回其大写，否则返回该参数
/****************************************************************************/
1.return 语句的作用
      (1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。
      (2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。
      (3) return后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。
  2.break语句的作用
    （1）break在循环体内，强行结束循环的执行，也就是结束整个循环过程，不在判断执行循环的条件是否成立，直接转向循环语句下面的语句。
    （2）当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。
  3.continue 语句的作用
      终止本次循环的执行，即跳过当前这次循环中continue语句后尚未执行的语句，接着进行下一次循环条件的判断。



while (cin.get() != '\n')
            continue;  
   这个循环体的作用就是清空输入缓冲区，也可以用cin.sync()达到同样的目的。


const的使用:
*********************const修饰函数的参数****************
1、用const修饰函数的参数时，只修饰输入参数，不修饰输出参数
2、用const修饰函数的参数时，当参数是内部数据类型，并按值传递，不需要用const修饰，这种函数本身会产生临时变量用于复制该参数。

*********************const修饰函数的返回值****************
1、如果返回值是内部数据类型，并按值传递时，不需要用const修饰。
2、如果返回值是指针类型，那么返回值的内容不能被修改。
3、如果返回值是引用类型，这种场合比较少，一般出现在重载类的赋值运算符函数中，目的是实现链式表达（a=b=c）。如果用cons修饰，那么返回值的内容不能被修改。

*********************const修饰函数本身****************
1、const位于函数声明尾部，表示该函数不会修改数据成员。
2、const成员函数不可以修改对象的数据，不管对象是否具有const性质。
3、对于采用mutable修饰的数据成员，任何情况都可以修改。


左值与右值：
  1 .左值可以寻址，而右值不可以。

  2 .左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。

  3 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。
补充：
1)  对于自定义的类型，允许调用成员函数修改。且只能被 const reference 指向。
2） 对于基础类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰(cv-qualitification ignored)



const函数与非const函数的调用规则

const对象默认调用const成员函数，非const对象默认调用非const成员函数；

若非const对象想调用const成员函数，则需要显示的转化，例((constStudent&)obj).getAge();

若const对象想调用非const成员函数，同理进行强制类型转换const_cast < Student&>(constObj).getAge();(注意constObj一定要加括号)
当类中只有一种函数存在的情况 
- 
非const对象可以调用const成员函数或者非const成员函数 
- const对象只能调用const成员函数，若直接调用非const成员函数编译器会报错。

用宏获取结构体中某个元素相对于结构体头的偏移地址：
#define FIND(struc,e) (size_t)&(((struc*)0)->e)
先将0强制转化为struc*类型，这样，它的首地址就是0，因此偏移量就等于e的绝对地址，再将其转换为int型的即可。

堆与栈
栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
堆区（heap）： 一般由程序员分配释放， 若程序员不释放会导致内存泄露，程序结束时可能由OS回收，与数据结构的堆不同
全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放
文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放
程序代码区：存放函数体的二进制代码

虚函数
作用：用基类指针去调用子类函数，实现多态。 实现方法：虚函数表，在一个有虚函数的类的开头有虚函数指针
可以通过函数指针强行指向类的第一个指针指向的函数地址，来实现调用，这种方法可以直接调用private函数

指针和数组名的区别：指针占空间，数组名不占

指针减法
会自动除以一个sizeof(当前类型)

用派生类指针指向基类

noexcept用法：
noexcept最有用的地方是用在move constructor和move assignment上，你的move操作如果不是noexcept的，很多情况下即使逻辑上可以move，编译器也会执行copy
destructor一定用noexcept

一般我们用基类指针指向派生类，实现多态， 而用派生类指针指向基类是非法的，如果非要这么做，则需使用dynamic_cast
Derived *d = dynamic_cast<Derived *>( new Base());

STL使用注意点：
1、当使用基于连续内存（vector,array,deque）的容器，因为涉及内存的复制移动，优先保存对象的指针 
2、当使用基于节点内存(list,map,set)的容器，因为不涉及内存的复制移动，优先保存对象
3、如果需要保存一些机器资源（例如：文件句柄，命名管道，套接字等），优先保存对象的指针
4、如果保存对象的指针，需要在容器使用完毕后，释放内存
例子：
for(auto it=vecA.begin();it!=vecA.end();++it)
{
if(NULL!=(*it))
delete (*it);
(*it)=NULL;  //将指针设置为NULL，防止误用
}
vecA.clear(); //清空整个容器
5、当使用迭代器删除容器中的元素时，删除完成后需要将迭代器重新指向正确的位置
6、at()函数具备边界检查功能。
7、当需要使用数组保存固定个数的数据时，使用array容器，需要两个参数：数据类型和元素个数

环境变量路径：
计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment

函数压栈顺序：
从右往左

不要在一个const成员函数中调用non-const成员函数，反之则可以。
const可被施加在任何作用域类的对象、函数参数、函数返回类型、成员函数本体。
当const和non-const成员函数具有等价的实现时，令non-const版本调用const避免代码重复。

C++中new 一个对象的时候加括号和不加括号：
1、加括号调用没有参数的构造函数，不加括号调用默认构造函数或唯一的构造函数，看需求
2、C++在new时的初始化的规律可能为：对于有构造函数的类，不论有没有括号，都用构造函数进行初始化；如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。

https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5

C++中结构体与类的区别（struct与class的区别）
1、默认的继承访问权限：struct是public的，class是private的。（struct B : A）注：究竟是public继承还是private继承，取决于子类而不是基类。
2、struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。

C++11的关键字final有两个用途：(1)、禁止虚函数被重写；(2)、禁止基类被继承。
在派生类中，可以同时使用overried和final。

https://blog.csdn.net/xdgs_2005/article/details/44249881?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v25-4.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v25-4.nonecase