
---
author: "司拓"
date: 2020-10-19
title: "算法笔记"
tags: [
    "算法"
]
categories: [
    "算法"
]
---

## 二分查找

二分查找法主要是解决在“一堆数中找出指定的数”这类问题。

其中一堆数必须具备的特征：

1. 存储在数组中
2. 有序排列

算法思想：

 在一个包含x的数组内，二分查找通过对范围的跟踪来解决问题。开始时，范围就是整个数组。通过将范围中间的元素与x比较并丢弃一半范围，范围就被缩小。这个过程一直持续，直到在x被发现，或者那个能够包含t的范围已成为空。

中间下标值的计算：

如果写成(low+high)/2，low+high可能会溢出，从而导致数组访问出错。改进的方法是将计算方式写成如下形式：low+ ( (high-low) >>1)。

1. 二分查找元素x的下标，如无 return -1

   ```c++
   int binarySearch(int *a, int left, int right, int x)
   {
   	if (nullptr == a || left > right || left < 0)
   		return -1;
   	int mid;
   	while (left <= right)//注意是<=，若是<会找不到边界值情况
   	{
   		mid = left + ((right - left) >> 1);
   		if (x < a[mid])
   			right = mid - 1; //[left,mid-1]
   		else if (x > a[mid])
   			left = mid + 1; //[mid+1,right]
   		else
   			return mid;
   	}
   	return -1;
   }
   ```
   
2. 二分查找返回x(可能有重复)第一次出现的下标，如无return -1

   ```c++
   int binS_first(int *a, int low, int high, int x)
   {
   	if (NULL == a || low > high || low < 0) return -1;
   	int mid;
   	while (low < high)
   	{
   		mid = low + ((high - low) >> 1);//计算中点
   		if (x > a[mid])// <x ,调整起点或者终点
   			low = mid + 1;
   		else // >=x
   			high = mid;
   	}
   	if (a[low] == x)
   		return low;
   	return -1;
   }
   ```

   我们只需找到x重复出现情况下的第一次出现的下标。则我们只需用a[mid]和元素x进行比较，当a[mid]<x时

   此时待查元素肯定在待查区间的右半部分 显然此时 不包括 mid 所以有 low = mid+1, 若a[mid]>=x时, 因为我

   们查找的是x第一次出现的位置,我们不关心x最后出现的位置,所以此时high下标为mid,直到 low == high 终止

   循环，并且比较a[low]是否为x,若是则 找到。

   总的思路是：

   把有序序列分成2个序列:[first,mid][mid+1,last) 当 a[mid]<x 时 使用序列[mid + 1,last)

   当 a[mid]>=x 时 使用序列[first,mid]。

3. 二分查找返回x(可能有重复)最后一次出现的下标，如无return -1

   ```c++
   int binS_last(int *a, int low, int high, int x)
   {
   	if (NULL == a || low > high || low < 0)
   		return -1;
   	int mid;
   	while (low + 1 < high)//**
   	{
   		mid = low + ((high - low) >> 1);
   		if (x >= a[mid])  // <=x
   			low = mid;
   		else  // >x
   			high = mid - 1;
   	}
   	if (a[high] == x)//先判断high
   		return high;
   	else if (a[low] == x)
   		return low;
   	return -1;
   }
   ```

   在 while中我们假定 low+1 < high,否则在只有两个或者一个元素时 我们只需在while循环之外判断即可。

   接下来的while 情况和问题2等价。我们现在关心的是 x(可能有重复)最后一次出现的下标，所以现在我们不关心他

   第一次出现下标的位置, 当 a[mid]<=x 时 low = mid, 否则 a[mid] >x 此时 high = mid -1。

   二分查找返回x(可能有重复)第一次(最后一次)出现的下标找最小的等号放>=x位置(high),找最大的等号放<=x的位置(low)。
   其中a[mid]在和待查找元素x比较中带 = 的，在对low 或者high赋值时一定为 mid，其它情况(<或>)则为mid+(-)1.

4. 二分查找返回刚好小于x的元素下标，如无return -1。

5. 二分查找返回刚好大于x的元素下标。

6.  返回有序数列某一个元素重复出现的次数。

   

时间复杂度：O(log n)

#include <algorithm>

**lower_bound()：**返回的是被查序列中第一个大于等于查找值的指针；

用法：int t=lower_bound(a+l,a+r,m)-a
解释：在升序排列的a数组内二分查找[l,r)区间内的值为m的元素。返回m在数组中的下标。
特殊情况：
1.如果m在区间中没有出现过，那么返回第一个比m大的数的下标。
2.如果m比所有区间内的数都大，那么返回r。这个时候会越界，小心。
3.如果区间内有多个相同的m，返回第一个m的下标。
时间复杂度：
一次查询O(log n)，n为数组长度。

**upper_bound()：**返回的是被查序列中第一个大于查找值得指针；

用法：int t=upper_bound(a+l,a+r,m)-a
解释：在升序排列的a数组内二分查找[l,r)区间内的值为m的元素。返回m在数组中的下标+1。
特殊情况：
1.如果m在区间中没有出现过，那么返回第一个比m大的数的下标。
2.如果m比所有区间内的数都大，那么返回r。这个时候会越界，小心。
3.如果区间内有多个相同的m，返回最后一个m的下标+1。
时间复杂度：
一次查询O(log n)，n为数组长度。

二分查找法的缺陷
二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：

必须有序，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。

数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。

解决这些缺陷问题更好的方法应该是使用*二叉查找树*了，最好自然是自平衡二叉查找树了，自能高效的（O(n log n)）构建有序元素集合，又能如同二分查找法一样快速（O(log n)）的搜寻目标数。



## 位操作

1. 右移一位，表示除以2；左移一位，表示乘以2

2. 交换两个数

   ```c++
   a ^= b;
   b ^= a;
   a ^= b;
   ```

3. 判断奇偶数

   只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。

   ```
   0==(a&1)
   ```

4. 交换符号

   整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

   ```
   c = ~c + 1;
   ```

   

5. 求绝对值

   整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作

   ```c++
   int abs(int a) 
   {
     int i = a >> 31;
     return i == 0 ? a : (~a + 1);
   }
   ```
   
6. 统计二进制中 1 的个数

   a &= (a-1)  每计算一次，原二进制中的数就少一个1。

   ```
   count = 0  
   while(a){  
     a = a & (a - 1);  
     count++;  
   }  
   ```

   

   ## 单链表

   使用快慢指针找链表的中点：
   1. 首先我们设置两个指针slow和fast，slow指针每次移动一步，fast指针每次移动两步； 
   2. 如果链表中节点个数为偶数时，当快指针无法继续移动时，慢指针刚好指向中点；如果链表中节点个数为奇数时，当快指针走完，慢指针指向中点前一个节点。
   
      

